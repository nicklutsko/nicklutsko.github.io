"use strict";

exports.__esModule = true;

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var React = require('react');

var citations = [];
var referenceInstances = [];

var citationsChangeHandler = {
  set: function set(target, property, value) {
    referenceInstances.forEach(function (referenceInstance) {
      referenceInstance.forceUpdate();
    });
    target[property] = value;
    return true;
  }
};

var citationsProxy = new Proxy(citations, citationsChangeHandler);

var References = function (_React$Component) {
  _inherits(References, _React$Component);

  function References() {
    _classCallCheck(this, References);

    var _this = _possibleConstructorReturn(this, _React$Component.call(this));

    referenceInstances.push(_this);
    return _this;
  }

  References.prototype.render = function render() {
    return React.createElement(
      "div",
      { id: "references" },
      React.createElement(
        "h1",
        null,
        "References"
      ),
      React.createElement(
        "ol",
        null,
        citations.map(function (citation, index) {
          return React.createElement(
            "li",
            { key: index },
            React.createElement(
              "a",
              { href: citation.url, target: "_blank" },
              citation.title
            ),
            ", ",
            citation.authors,
            ".",
            React.createElement(
              "em",
              null,
              citation.venue ? ' ' + citation.venue + '.' : ''
            ),
            citation.date ? ' ' + citation.date + '.' : ''
          );
        })
      )
    );
  };

  return References;
}(React.Component);

var Cite = function (_React$Component2) {
  _inherits(Cite, _React$Component2);

  function Cite(props) {
    _classCallCheck(this, Cite);

    var _this2 = _possibleConstructorReturn(this, _React$Component2.call(this, props));

    var _this2$props = _this2.props,
        authors = _this2$props.authors,
        url = _this2$props.url,
        title = _this2$props.title,
        date = _this2$props.date,
        venue = _this2$props.venue,
        id = _this2$props.id;

    var foundCitation = citationsProxy.find(function (citation) {
      return citation.id === id && id !== undefined;
    });
    if (foundCitation) {
      _this2.state = _extends({
        citationNumber: citationsProxy.indexOf(foundCitation) + 1
      }, foundCitation);
      if (authors || title) {
        console.warn('Warning: Ignoring authors and title as Cite with the given id was declared before.');
      }
    } else if (authors && title) {
      var newCitation = { authors: authors, url: url, title: title, date: date, venue: venue, id: id };
      citationsProxy.push(newCitation);
      _this2.state = _extends({ citationNumber: citationsProxy.length }, newCitation);
    } else {
      console.warn("Warning: Cite with given id not found or invalid id. Check if a Cite with the id \"" + id + "\" was declared before this line.");
      _this2.state = {};
    }
    return _this2;
  }

  Cite.prototype.render = function render() {
    var _state = this.state,
        citationNumber = _state.citationNumber,
        authors = _state.authors,
        title = _state.title,
        url = _state.url;

    return React.createElement(
      "a",
      { title: title + ", " + authors, href: url || '#references' },
      "[",
      citationNumber,
      "]"
    );
  };

  return Cite;
}(React.Component);

Cite._idyll = {
  name: 'Cite',
  tagType: 'closed',
  props: [{
    name: 'authors',
    type: 'string'
  }, {
    name: 'title',
    type: 'string'
  }, {
    name: 'url',
    type: 'string',
    description: 'Link to the citation.'
  }, {
    name: 'date',
    type: 'string'
  }, {
    name: 'venue',
    type: 'string'
  }, {
    name: 'id',
    type: 'string',
    description: 'Can be used to refer a previously stated citation using the same id.'
  }]
};
exports.References = References;

Cite.References = References;
exports.default = Cite;