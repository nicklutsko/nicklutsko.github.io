var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _objectWithoutProperties(obj, keys) { var target = {}; for (var i in obj) { if (keys.indexOf(i) >= 0) continue; if (!Object.prototype.hasOwnProperty.call(obj, i)) continue; target[i] = obj[i]; } return target; }

import React from 'react';
import ReactDOM from 'react-dom';
import scrollparent from 'scrollparent';
import scrollMonitor from 'scrollmonitor';
import ReactJsonSchema from './utils/schema2element';
import entries from 'object.entries';
import values from 'object.values';
import { generatePlaceholder } from './components/placeholder';
import AuthorTool from './components/author-tool';
import { getChildren } from 'idyll-ast';
import equal from 'fast-deep-equal';

import * as layouts from 'idyll-layouts';
import * as themes from 'idyll-themes';

import { getData, getVars, filterASTForDocument, splitAST, translate, findWrapTargets, filterIdyllProps, mapTree, evalExpression, hooks, scrollMonitorEvents } from './utils';

var updatePropsCallbacks = [];
var updateRefsCallbacks = [];
var scrollWatchers = [];
var scrollOffsets = {};
var refCache = {};
var evalContext = {};
var scrollContainer = void 0;

var getLayout = function getLayout(layout) {
  return layouts[layout.trim()] || {};
};

var getTheme = function getTheme(theme) {
  return themes[theme.trim()] || {};
};

var getRefs = function getRefs() {
  var refs = {};
  if (!scrollContainer) {
    return refCache;
  }

  scrollWatchers.forEach(function (watcher) {
    // left and right props assume no horizontal scrolling
    var watchItem = watcher.watchItem,
        callbacks = watcher.callbacks,
        container = watcher.container,
        recalculateLocation = watcher.recalculateLocation,
        offsets = watcher.offsets,
        watcherProps = _objectWithoutProperties(watcher, ['watchItem', 'callbacks', 'container', 'recalculateLocation', 'offsets']);

    refs[watchItem.dataset.ref] = _extends({}, watcherProps, refCache[watchItem.dataset.ref], {
      domNode: watchItem
    });
  });

  return _extends({}, refCache, refs);
};

var wrapperKey = 0;
var createWrapper = function createWrapper(_ref) {
  var theme = _ref.theme,
      layout = _ref.layout,
      authorView = _ref.authorView,
      userViewComponent = _ref.userViewComponent;

  return function (_React$PureComponent) {
    _inherits(Wrapper, _React$PureComponent);

    function Wrapper(props) {
      _classCallCheck(this, Wrapper);

      var _this = _possibleConstructorReturn(this, _React$PureComponent.call(this, props));

      _this.key = props.idyllASTNode.id || wrapperKey++;
      _this.ref = {};
      _this.onUpdateRefs = _this.onUpdateRefs.bind(_this);
      _this.onUpdateProps = _this.onUpdateProps.bind(_this);

      var vars = values(props.__vars__);
      var exps = values(props.__expr__);

      _this.usesRefs = exps.some(function (v) {
        return v.includes('refs.');
      });

      _this.state = { hasError: false, error: null };

      // listen for props updates IF we care about them
      if (vars.length || exps.length) {
        // called with new doc state
        // when any component calls updateProps()
        updatePropsCallbacks.push(_this.onUpdateProps);
        _this.state = _this.onUpdateProps(props.initialState, Object.keys(props), true);
      }

      // listen for ref updates IF we care about them
      if (props.hasHook || _this.usesRefs) {
        updateRefsCallbacks.push(_this.onUpdateRefs);
      }
      return _this;
    }

    Wrapper.prototype.componentDidCatch = function componentDidCatch(error, info) {
      this.setState({ hasError: true, error: error });
    };

    Wrapper.prototype.onUpdateProps = function onUpdateProps(newState, changedKeys, initialRender) {
      var _props = this.props,
          __vars__ = _props.__vars__,
          __expr__ = _props.__expr__;

      // were there changes to any vars we track?
      // or vars our expressions reference?

      var shouldUpdate = initialRender || changedKeys.some(function (k) {
        return values(__vars__).includes(k) || values(__expr__).some(function (expr) {
          return expr.includes(k);
        });
      });
      // if nothing we care about changed bail out and don't re-render
      if (!shouldUpdate) return;

      // update this component's state
      var nextState = {};
      // pull in the latest value for any tracked vars
      Object.keys(__vars__).forEach(function (key) {
        nextState[key] = newState[__vars__[key]];
      });
      // re-run this component's expressions using the latest doc state
      Object.keys(__expr__).forEach(function (key) {
        nextState[key] = evalExpression(_extends({}, newState, { refs: getRefs() }), __expr__[key], key, evalContext);
      });

      if (initialRender) {
        return Object.assign({ hasError: false }, nextState);
      }
      // trigger a re-render of this component
      // and more importantly, its wrapped component
      this.setState(Object.assign({ hasError: false, error: null }, nextState));
    };

    Wrapper.prototype.onUpdateRefs = function onUpdateRefs(newState) {
      var __expr__ = this.props.__expr__;


      if (this.usesRefs) {
        var nextState = { refs: newState.refs };
        entries(__expr__).forEach(function (_ref2) {
          var key = _ref2[0],
              val = _ref2[1];

          if (!val.includes('refs.')) {
            return;
          }
          nextState[key] = evalExpression(newState, val, key, evalContext);
        });

        // trigger a render with latest state
        this.setState(nextState);
      }
    };

    Wrapper.prototype.componentWillUnmount = function componentWillUnmount() {
      var propsIndex = updatePropsCallbacks.indexOf(this.onUpdateProps);
      if (propsIndex > -1) updatePropsCallbacks.splice(propsIndex, 1);

      var refsIndex = updateRefsCallbacks.indexOf(this.onUpdateRefs);
      if (refsIndex > -1) updateRefsCallbacks.splice(refsIndex, 1);
    };

    Wrapper.prototype.render = function render() {
      var _this2 = this;

      if (this.state.hasError) {
        return React.createElement(
          'div',
          { style: { border: 'solid red 1px', padding: 10 } },
          this.state.error.message
        );
      }

      var state = filterIdyllProps(this.state, this.props.isHTMLNode);

      var _filterIdyllProps = filterIdyllProps(this.props, this.props.isHTMLNode),
          children = _filterIdyllProps.children,
          passThruProps = _objectWithoutProperties(_filterIdyllProps, ['children']);

      var childComponent = null;
      var uniqueKey = this.key + '-help';
      var returnComponent = React.Children.map(children, function (c, i) {
        childComponent = c;
        return React.cloneElement(c, _extends({
          key: _this2.key + '-' + i,
          idyll: {
            theme: getTheme(theme),
            layout: getLayout(layout),
            authorView: authorView
          }
        }, state, passThruProps));
      });
      var metaData = childComponent.type._idyll;
      if (authorView && metaData && metaData.props) {
        // ensure inline elements do not have this overlay
        if (metaData.displayType === undefined || metaData.displayType !== 'inline') {
          var ViewComponent = userViewComponent || AuthorTool;
          return React.createElement(ViewComponent, {
            idyllASTNode: this.props.idyllASTNode,
            component: returnComponent,
            authorComponent: childComponent,
            uniqueKey: uniqueKey
          });
        }
      }
      return returnComponent;
    };

    return Wrapper;
  }(React.PureComponent);
};

var getDerivedValues = function getDerivedValues(dVars) {
  var o = {};
  Object.keys(dVars).forEach(function (key) {
    return o[key] = dVars[key].value;
  });
  return o;
};

var IdyllRuntime = function (_React$PureComponent2) {
  _inherits(IdyllRuntime, _React$PureComponent2);

  function IdyllRuntime(props) {
    _classCallCheck(this, IdyllRuntime);

    var _this3 = _possibleConstructorReturn(this, _React$PureComponent2.call(this, props));

    _this3.state = {};
    _this3.scrollListener = _this3.scrollListener.bind(_this3);
    _this3.initScrollListener = _this3.initScrollListener.bind(_this3);
    var ast = filterASTForDocument(props.ast);

    var _splitAST = splitAST(getChildren(ast)),
        vars = _splitAST.vars,
        derived = _splitAST.derived,
        data = _splitAST.data,
        elements = _splitAST.elements;

    var Wrapper = createWrapper({
      theme: props.theme,
      layout: props.layout,
      authorView: props.authorView,
      userViewComponent: props.userViewComponent
    });

    var hasInitialized = false;
    var initialContext = {};
    // Initialize a custom context
    if (typeof props.context === 'function') {
      props.context({
        update: function update(newState) {
          if (!hasInitialized) {
            initialContext = Object.assign(initialContext, newState);
          } else {
            _this3.updateState(newState);
          }
        },
        data: function data() {
          return _this3.state;
        },
        onInitialize: function onInitialize(cb) {
          _this3._onInitializeState = cb;
        },
        onMount: function onMount(cb) {
          _this3._onMount = cb;
        },
        onUpdate: function onUpdate(cb) {
          _this3._onUpdateState = cb;
        }
      });
    }

    var dataStore = getData(data, props.datasets);
    var initialState = Object.assign({}, _extends({}, getVars(vars, initialContext), dataStore.syncData), initialContext, props.initialState ? props.initialState : {});

    var asyncDataStore = dataStore.asyncData;

    var asyncDataStoreKeys = Object.keys(asyncDataStore);
    asyncDataStoreKeys.forEach(function (key) {
      _this3.state[key] = asyncDataStore[key].initialValue;
    });

    asyncDataStoreKeys.map(function (key) {
      asyncDataStore[key].dataPromise.then(function (res) {
        var _extends2;

        _this3.updateState(_extends({}, _this3.state, (_extends2 = {}, _extends2[key] = res, _extends2)));
      }).catch(function (e) {
        return console.error('Error while resolving the data' + e);
      });
    });
    var derivedVars = _this3.derivedVars = getVars(derived, initialState);

    var state = _this3.state = _extends({}, _this3.state, initialState, getDerivedValues(derivedVars));

    _this3.updateState = function (newState) {
      // merge new doc state with old
      var newMergedState = _extends({}, _this3.state, newState);
      // update derived values
      var newDerivedValues = getDerivedValues(getVars(derived, newMergedState));
      var nextState = _extends({}, newMergedState, newDerivedValues);

      var changedMap = {};
      var changedKeys = Object.keys(state).reduce(function (acc, k) {
        if (!equal(state[k], nextState[k])) {
          acc.push(k);
          changedMap[k] = nextState[k] || state[k];
        }
        return acc;
      }, []);

      // Update doc state reference.
      // We re-use the same object here so that
      // IdyllRuntime.state can be accurately checked in tests
      state = Object.assign(state, nextState);
      // pass the new doc state to all listeners aka component wrappers
      updatePropsCallbacks.forEach(function (f) {
        return f(state, changedKeys);
      });

      changedKeys.length && _this3._onUpdateState && _this3._onUpdateState(changedMap);
    };

    evalContext.__idyllUpdate = _this3.updateState;
    hasInitialized = true;
    _this3._onInitializeState && _this3._onInitializeState();

    // Put these in to avoid hard errors if people are on the latest
    // CLI but haven't updated their local default components
    var fallbackComponents = {
      'text-container': generatePlaceholder('TextContainer'),
      'full-width': generatePlaceholder('FullWidth')
    };

    // Components that the Document needs to function properly
    var internalComponents = {
      Wrapper: Wrapper
    };

    Object.keys(internalComponents).forEach(function (key) {
      if (props.components[key]) {
        console.warn('Warning! You are including a component named ' + key + ', but this is a reserved Idyll component. Please rename your component.');
      }
    });

    var components = Object.assign(fallbackComponents, props.components, internalComponents);

    var rjs = new ReactJsonSchema(components);
    var schema = translate(ast);
    var wrapTargets = findWrapTargets(schema, _this3.state, props.components);
    var refCounter = 0;
    var transformedSchema = mapTree(schema, function (node) {
      // console.log('mapoing ', node.component || node.type);
      if (!node.component) {
        if (node.type && node.type === 'textnode') return node.value;
      }

      // transform refs from strings to functions and store them
      if (node.ref || node.hasHook) {
        node.refName = node.ref || node.component + (refCounter++).toString();
        node.ref = function (el) {
          if (!el) return;
          var domNode = ReactDOM.findDOMNode(el);
          domNode.dataset.ref = node.refName;
          scrollOffsets[node.refName] = node.scrollOffset || 0;
          refCache[node.refName] = {
            props: node,
            domNode: domNode,
            component: el
          };
        };
        refCache[node.refName] = {
          props: node,
          domNode: null
        };
      }
      //Inspect for isHTMLNode  props and to check for dynamic components.
      if (!wrapTargets.includes(node)) {
        // Don't include the AST node reference on unwrapped components
        var _idyllASTNode = node.idyllASTNode,
            rest = _objectWithoutProperties(node, ['idyllASTNode']);

        return rest;
      }

      var component = node.component,
          children = node.children,
          idyllASTNode = node.idyllASTNode,
          key = node.key,
          _node$__vars__ = node.__vars__,
          __vars__ = _node$__vars__ === undefined ? {} : _node$__vars__,
          _node$__expr__ = node.__expr__,
          __expr__ = _node$__expr__ === undefined ? {} : _node$__expr__,
          props = _objectWithoutProperties(node, ['component', 'children', 'idyllASTNode', 'key', '__vars__', '__expr__']);

      // assign the initial values for tracked vars and expressions


      Object.keys(props).forEach(function (k) {
        if (__vars__[k]) {
          node[k] = state[__vars__[k]];
        }
        if (__expr__[k] !== undefined) {
          if (hooks.indexOf(k) > -1) {
            return;
          }
          node[k] = evalExpression(_extends({}, state, { refs: getRefs() }), __expr__[k], k, evalContext);
        }
      });
      var resolvedComponent = rjs.resolveComponent(node);
      var isHTMLNode = typeof resolvedComponent === 'string';

      return {
        component: Wrapper,
        __vars__: __vars__,
        __expr__: __expr__,
        idyllASTNode: idyllASTNode,
        isHTMLNode: isHTMLNode,
        hasHook: node.hasHook,
        refName: node.refName,
        initialState: _this3.state,
        updateProps: function updateProps(newProps) {
          // init new doc state object
          var newState = {};
          // iterate over passed in updates
          Object.keys(newProps).forEach(function (k) {
            // if a tracked var was updated get its new value
            if (__vars__[k]) {
              newState[__vars__[k]] = newProps[k];
            }
          });
          _this3.updateState(newState);
        },
        children: [filterIdyllProps(node, isHTMLNode)]
      };
    });

    _this3.kids = rjs.parseSchema(transformedSchema);
    return _this3;
  }

  IdyllRuntime.prototype.scrollListener = function scrollListener() {
    var _this4 = this;

    var refs = getRefs();
    updateRefsCallbacks.forEach(function (f) {
      return f(_extends({}, _this4.state, { refs: refs }));
    });
  };

  IdyllRuntime.prototype.initScrollListener = function initScrollListener(el) {
    var _this5 = this;

    if (!el) return;

    var scroller = scrollparent(el);
    if (scroller === document.documentElement || scroller === document.body || scroller === window) {
      scroller = window;
      scrollContainer = scrollMonitor;
    } else {
      scrollContainer = scrollMonitor.createContainer(scroller);
    }
    Object.keys(refCache).forEach(function (key) {
      var _refCache$key = refCache[key],
          props = _refCache$key.props,
          domNode = _refCache$key.domNode;

      var watcher = scrollContainer.create(domNode, scrollOffsets[key]);
      hooks.forEach(function (hook) {
        if (props[hook]) {
          watcher[scrollMonitorEvents[hook]](function () {
            evalExpression(_extends({}, _this5.state, { refs: getRefs() }), props[hook], hook, evalContext)();
          });
        }
      });
      scrollWatchers.push(watcher);
    });
    scroller.addEventListener('scroll', this.scrollListener);
  };

  IdyllRuntime.prototype.updateDerivedVars = function updateDerivedVars(newState) {
    var _this6 = this;

    var context = {};
    Object.keys(this.derivedVars).forEach(function (dv) {
      _this6.derivedVars[dv].value = _this6.derivedVars[dv].update(newState, _this6.state, context);
      context[dv] = _this6.derivedVars[dv].value;
    });
  };

  IdyllRuntime.prototype.getDerivedVars = function getDerivedVars() {
    var _this7 = this;

    var dvs = {};
    Object.keys(this.derivedVars).forEach(function (dv) {
      dvs[dv] = _this7.derivedVars[dv].value;
    });
    return dvs;
  };

  IdyllRuntime.prototype.componentDidMount = function componentDidMount() {
    var _this8 = this;

    var refs = getRefs();
    updateRefsCallbacks.forEach(function (f) {
      return f(_extends({}, _this8.state, { refs: refs }));
    });
    this._onMount && this._onMount();
  };

  IdyllRuntime.prototype.render = function render() {
    return React.createElement(
      'div',
      { className: 'idyll-root', ref: this.initScrollListener },
      this.kids
    );
  };

  return IdyllRuntime;
}(React.PureComponent);

IdyllRuntime.defaultProps = {
  layout: 'blog',
  theme: 'github',
  authorView: false,
  insertStyles: false
};

export default IdyllRuntime;