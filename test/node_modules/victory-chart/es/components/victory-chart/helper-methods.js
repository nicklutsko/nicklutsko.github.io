import _values from "lodash/values";
import _sortBy from "lodash/sortBy";
import _invert from "lodash/invert";

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

import Axis from "../../helpers/axis";
import Wrapper from "../../helpers/wrapper";
import React from "react";
import { Helpers, Collection, Log, Domain } from "victory-core";

var identity = function (x) {
  return x;
};

export default {
  getChildComponents: function (props, defaultAxes) {
    var childComponents = React.Children.toArray(props.children);
    if (childComponents.length === 0) {
      return [defaultAxes.independent, defaultAxes.dependent];
    }

    var axisComponents = {
      dependent: Axis.getAxisComponentsWithParent(childComponents, "dependent"),
      independent: Axis.getAxisComponentsWithParent(childComponents, "independent")
    };

    if (axisComponents.dependent.length === 0 && axisComponents.independent.length === 0) {
      return childComponents.concat([defaultAxes.independent, defaultAxes.dependent]);
    }
    if (axisComponents.independent.length > 1) {
      var msg = "Only one independent VictoryAxis component is allowed when " + "using the VictoryChart wrapper. Only the first axis will be used. Please compose " + "multi-axis charts manually";
      Log.warn(msg);
      var dataComponents = this.getDataComponents(childComponents);
      return Collection.removeUndefined(dataComponents.concat([].concat(_toConsumableArray(axisComponents.dependent), [axisComponents.independent[0]])));
    }
    return childComponents;
  },
  getDefaultDomainPadding: function (childComponents, horizontal) {
    var groupComponent = childComponents.filter(function (child) {
      return child.type && child.type.role && child.type.role === "group-wrapper";
    });

    if (groupComponent.length < 1) {
      return undefined;
    }

    var _groupComponent$0$pro = groupComponent[0].props,
        offset = _groupComponent$0$pro.offset,
        children = _groupComponent$0$pro.children;

    return horizontal ? { y: offset * children.length / 2 } : { x: offset * children.length / 2 };
  },
  getDataComponents: function (childComponents) {
    var findDataComponents = function (children) {
      return children.reduce(function (memo, child) {
        if (child.type && child.type.role === "axis") {
          return memo;
        } else if (child.props && child.props.children) {
          return memo.concat(findDataComponents(React.Children.toArray(child.props.children)));
        }
        return memo.concat(child);
      }, []);
    };

    return findDataComponents(childComponents);
  },
  getDomain: function (props, axis, childComponents) {
    childComponents = childComponents || React.Children.toArray(props.children);
    var domain = Wrapper.getDomain(props, axis, childComponents);
    var orientations = Axis.getAxisOrientations(childComponents);
    return Domain.orientDomain(domain, orientations, axis);
  },
  getAxisOffset: function (props, calculatedProps) {
    var axisComponents = calculatedProps.axisComponents,
        scale = calculatedProps.scale,
        origin = calculatedProps.origin,
        originSign = calculatedProps.originSign;
    // make the axes line up, and cross when appropriate

    var axisOrientations = {
      x: Axis.getOrientation(axisComponents.x, "x", originSign.x),
      y: Axis.getOrientation(axisComponents.y, "y", originSign.y)
    };
    var orientationOffset = {
      x: axisOrientations.y === "left" ? 0 : props.width,
      y: axisOrientations.x === "bottom" ? props.height : 0
    };
    var calculatedOffset = {
      x: Math.abs(orientationOffset.x - scale.x(origin.x)),
      y: Math.abs(orientationOffset.y - scale.y(origin.y))
    };

    return {
      x: axisComponents.x && axisComponents.x.offsetX !== undefined ? axisComponents.x.offsetX : calculatedOffset.x,
      y: axisComponents.y && axisComponents.y.offsetY !== undefined ? axisComponents.y.offsetY : calculatedOffset.y
    };
  },
  getTicksFromData: function (calculatedProps, axis) {
    var currentAxis = Helpers.getCurrentAxis(axis, calculatedProps.horizontal);
    var stringMap = calculatedProps.stringMap[currentAxis];
    // if tickValues are defined for an axis component use them
    var categoryArray = calculatedProps.categories[currentAxis];
    var ticksFromCategories = categoryArray && Collection.containsOnlyStrings(categoryArray) ? categoryArray.map(function (tick) {
      return stringMap[tick];
    }) : categoryArray;
    var ticksFromStringMap = stringMap && _values(stringMap);
    // when ticks is undefined, axis will determine its own ticks
    return ticksFromCategories && ticksFromCategories.length !== 0 ? ticksFromCategories : ticksFromStringMap;
  },
  getTicksFromAxis: function (calculatedProps, axis, component) {
    var tickValues = component.props.tickValues;
    if (!tickValues) {
      return undefined;
    }
    var currentAxis = Helpers.getCurrentAxis(axis, calculatedProps.horizontal);
    var stringMap = calculatedProps.stringMap[currentAxis];
    return Collection.containsOnlyStrings(tickValues) && stringMap ? tickValues.map(function (tick) {
      return stringMap[tick];
    }) : tickValues;
  },
  getTicks: function () {
    return this.getTicksFromAxis.apply(this, arguments) || this.getTicksFromData.apply(this, arguments);
  },
  getTickFormat: function (component, axis, calculatedProps) {
    var currentAxis = Helpers.getCurrentAxis(axis, calculatedProps.horizontal);
    var stringMap = calculatedProps.stringMap[currentAxis];
    var tickValues = component.props.tickValues;
    var useIdentity = tickValues && !Collection.containsStrings(tickValues) && !Collection.containsDates(tickValues);
    if (useIdentity) {
      return identity;
    } else if (stringMap !== null) {
      var tickValueArray = _sortBy(_values(stringMap), function (n) {
        return n;
      });
      var invertedStringMap = _invert(stringMap);
      var dataNames = tickValueArray.map(function (tick) {
        return invertedStringMap[tick];
      });
      // string ticks should have one tick of padding at the beginning
      var dataTicks = [""].concat(_toConsumableArray(dataNames), [""]);
      return function (x) {
        return dataTicks[x];
      };
    } else {
      return undefined;
    }
  },
  createStringMap: function (props, axis, childComponents) {
    var allStrings = Wrapper.getStringsFromChildren(props, axis, childComponents);
    return allStrings.length === 0 ? null : allStrings.reduce(function (memo, string, index) {
      memo[string] = index + 1;
      return memo;
    }, {});
  }
};