import _without from "lodash/without";
import _range from "lodash/range";
import _isFunction from "lodash/isFunction";
import _defaultsDeep from "lodash/defaultsDeep";
import _defaults from "lodash/defaults";
import _includes from "lodash/includes";
import _uniqBy from "lodash/uniqBy";
import _assign from "lodash/assign";

import { Helpers, LabelHelpers, Scale, Domain, Collection } from "victory-core";

export default {
  getCalculatedValues: function (props) {
    var defaultStyles = this.getStyleObject(props);
    var style = this.getStyles(props, defaultStyles);
    var padding = Helpers.getPadding(props);
    var axis = this.getAxis(props);
    var axisType = this.getAxisType(props);
    var stringTicks = Helpers.stringTicks(props);
    var domain = this.getDomain(props, axis);
    var range = this.getRange(props, axis);
    var scale = this.getScale(props);
    var initialTicks = this.getTicks(props, scale);
    var ticks = axisType === "angular" ? this.filterTicks(initialTicks, scale) : initialTicks;
    var tickFormat = this.getTickFormat(props, scale, ticks);
    var radius = this.getRadius(props);
    return {
      axis: axis, style: style, padding: padding, stringTicks: stringTicks, axisType: axisType, scale: scale, ticks: ticks, tickFormat: tickFormat, domain: domain, range: range, radius: radius
    };
  },
  evaluateProp: function (prop, data, index) {
    return _isFunction(prop) ? prop(data, index) : prop;
  },
  evaluateStyle: function (style, data, index) {
    var _this = this;

    if (!style || !Object.keys(style).some(function (value) {
      return _isFunction(style[value]);
    })) {
      return style;
    }
    return Object.keys(style).reduce(function (prev, curr) {
      prev[curr] = _this.evaluateProp(style[curr], data, index);
      return prev;
    }, {});
  },


  // exposed for use by VictoryChart
  getDomain: function (props, axis) {
    var inherentAxis = this.getAxis(props);
    if (axis && axis !== inherentAxis) {
      return undefined;
    }
    var domain = void 0;
    if (Array.isArray(props.domain)) {
      domain = props.domain;
    } else if (props.domain && props.domain[inherentAxis]) {
      domain = props.domain[inherentAxis];
    } else if (Array.isArray(props.tickValues) && props.tickValues.length > 1) {
      domain = this.getDomainFromTickValues(props, axis);
    }
    var paddedDomain = Domain.padDomain(domain, props, inherentAxis);
    return domain ? Domain.cleanDomain(paddedDomain, props, inherentAxis) : undefined;
  },
  getDomainFromTickValues: function (props, axis) {
    var tickValues = props.tickValues,
        _props$startAngle = props.startAngle,
        startAngle = _props$startAngle === undefined ? 0 : _props$startAngle,
        _props$endAngle = props.endAngle,
        endAngle = _props$endAngle === undefined ? 360 : _props$endAngle;

    if (Helpers.stringTicks(props)) {
      return [1, tickValues.length];
    } else {
      var ticks = tickValues.map(function (value) {
        return +value;
      });
      var domain = [Collection.getMinValue(ticks), Collection.getMaxValue(ticks)];
      return axis === "x" && Math.abs(startAngle - endAngle) === 360 ? Domain.getSymmetricDomain(domain, ticks) : domain;
    }
  },
  getRadius: function (props) {
    var _Helpers$getPadding = Helpers.getPadding(props),
        left = _Helpers$getPadding.left,
        right = _Helpers$getPadding.right,
        top = _Helpers$getPadding.top,
        bottom = _Helpers$getPadding.bottom;

    var width = props.width,
        height = props.height;

    return Math.min(width - left - right, height - top - bottom) / 2;
  },
  getRange: function (props, axis) {
    // Return the range from props if one is given.
    if (props.range && props.range[axis]) {
      return props.range[axis];
    } else if (props.range && Array.isArray(props.range)) {
      return props.range;
    }
    var axisType = this.getAxisType(props);
    if (axisType === "angular") {
      var startAngle = Helpers.degreesToRadians(props.startAngle);
      var endAngle = Helpers.degreesToRadians(props.endAngle);
      return [startAngle, endAngle];
    }
    var radius = this.getRadius(props);
    return [props.innerRadius || 0, radius];
  },


  // exposed for use by VictoryChart
  getAxis: function (props, flipped) {
    var typicalAxis = props.dependentAxis ? "y" : "x";
    var invertedAxis = typicalAxis === "x" ? "y" : "x";
    return flipped ? invertedAxis : typicalAxis;
  },
  getAxisType: function (props) {
    var typicalType = props.dependentAxis ? "radial" : "angular";
    var invertedType = typicalType === "angular" ? "radial" : "angular";
    return props.horizontal ? invertedType : typicalType;
  },


  // exposed for use by VictoryChart (necessary?)
  getScale: function (props) {
    var axis = this.getAxis(props);
    var scale = Scale.getBaseScale(props, axis);
    var domain = this.getDomain(props, axis) || scale.domain();
    var range = this.getRange(props, axis);
    scale.range(range);
    scale.domain(domain);
    return scale;
  },
  getStyleObject: function (props) {
    var theme = props.theme,
        dependentAxis = props.dependentAxis;

    var generalAxisStyle = theme && theme.axis && theme.axis.style;
    var axisType = dependentAxis ? "dependentAxis" : "independentAxis";
    var specificAxisStyle = theme && theme[axisType] && theme[axisType].style;

    return generalAxisStyle && specificAxisStyle ? _defaultsDeep({}, specificAxisStyle, generalAxisStyle) : specificAxisStyle || generalAxisStyle;
  },
  getStyles: function (props, styleObject) {
    var style = props.style || {};
    styleObject = styleObject || {};
    var parentStyleProps = { height: "auto", width: "100%" };
    return {
      parent: _defaults(parentStyleProps, style.parent, styleObject.parent),
      axis: _defaults({}, style.axis, styleObject.axis),
      axisLabel: _defaults({}, style.axisLabel, styleObject.axisLabel),
      grid: _defaults({}, style.grid, styleObject.grid),
      ticks: _defaults({}, style.ticks, styleObject.ticks),
      tickLabels: _defaults({}, style.tickLabels, styleObject.tickLabels)
    };
  },
  getAxisAngle: function (props) {
    var axisAngle = props.axisAngle,
        startAngle = props.startAngle,
        axisValue = props.axisValue,
        dependentAxis = props.dependentAxis,
        scale = props.scale;

    var otherAxis = this.getAxis(props) === "y" ? "x" : "y";
    if (axisValue === undefined || !dependentAxis || scale[otherAxis] === undefined) {
      return axisAngle || startAngle;
    }
    return Helpers.radiansToDegrees(scale.x(axisValue));
  },
  getTickProps: function (props, calculatedValues, tick, index) {
    //eslint-disable-line max-params
    var axisType = calculatedValues.axisType,
        radius = calculatedValues.radius,
        scale = calculatedValues.scale,
        style = calculatedValues.style;

    var _getEvaluatedStyles = this.getEvaluatedStyles(style, tick, index),
        tickStyle = _getEvaluatedStyles.tickStyle;

    var tickPadding = tickStyle.padding || 0;
    var angularPadding = tickPadding; // TODO: do some geometry
    var axisAngle = axisType === "radial" ? this.getAxisAngle(props, scale) : undefined;
    return axisType === "angular" ? {
      index: index, datum: tick, style: tickStyle,
      x1: radius * Math.cos(scale(tick)),
      y1: -radius * Math.sin(scale(tick)),
      x2: (radius + tickPadding) * Math.cos(scale(tick)),
      y2: -(radius + tickPadding) * Math.sin(scale(tick))
    } : {
      style: style, index: index, datum: tick,
      x1: scale(tick) / 2 * Math.cos(axisAngle - angularPadding),
      x2: scale(tick) / 2 * Math.cos(axisAngle + angularPadding),
      y1: -(scale(tick) / 2) * Math.sin(axisAngle - angularPadding),
      y2: -(scale(tick) / 2) * Math.sin(axisAngle + angularPadding)
    };
  },
  getTickLabelProps: function (props, calculatedValues, tick, index) {
    //eslint-disable-line max-params
    var axisType = calculatedValues.axisType,
        radius = calculatedValues.radius,
        tickFormat = calculatedValues.tickFormat,
        style = calculatedValues.style,
        scale = calculatedValues.scale;

    var _getEvaluatedStyles2 = this.getEvaluatedStyles(style, tick, index),
        labelStyle = _getEvaluatedStyles2.labelStyle;

    var tickLabelComponent = props.tickLabelComponent;

    var labelPlacement = tickLabelComponent.props && tickLabelComponent.props.labelPlacement ? tickLabelComponent.props.labelPlacement : props.labelPlacement;
    var tickPadding = labelStyle.padding || 0;
    var angularPadding = 0; // TODO: do some geometry
    var axisAngle = axisType === "radial" ? this.getAxisAngle(props, scale) : undefined;
    var labelAngle = axisType === "angular" ? Helpers.radiansToDegrees(scale(tick)) : axisAngle + angularPadding;
    var textAngle = labelStyle.angle || LabelHelpers.getPolarAngle(_assign({}, props, { labelPlacement: labelPlacement }), labelAngle);
    var labelRadius = axisType === "angular" ? radius + tickPadding : scale(tick);
    var textAnchor = labelStyle.textAnchor || LabelHelpers.getPolarTextAnchor(_assign({}, props, { labelPlacement: labelPlacement }), labelAngle);
    return {
      index: index, datum: tick, style: labelStyle,
      angle: textAngle,
      textAnchor: textAnchor,
      text: tickFormat(tick, index),
      x: labelRadius * Math.cos(Helpers.degreesToRadians(labelAngle)),
      y: -labelRadius * Math.sin(Helpers.degreesToRadians(labelAngle))
    };
  },
  getGridProps: function (props, calculatedValues, tick, index) {
    //eslint-disable-line max-params
    var axisType = calculatedValues.axisType,
        radius = calculatedValues.radius,
        style = calculatedValues.style,
        scale = calculatedValues.scale;
    var startAngle = props.startAngle,
        endAngle = props.endAngle,
        _props$innerRadius = props.innerRadius,
        innerRadius = _props$innerRadius === undefined ? 0 : _props$innerRadius;

    var _getEvaluatedStyles3 = this.getEvaluatedStyles(style, tick, index),
        gridStyle = _getEvaluatedStyles3.gridStyle;

    var angle = scale(tick);
    return axisType === "angular" ? {
      index: index, datum: tick, style: gridStyle,
      x1: this.getPosition(radius, angle, "x"),
      y1: this.getPosition(radius, angle, "y"),
      x2: this.getPosition(innerRadius, angle, "x"),
      y2: this.getPosition(innerRadius, angle, "y")
    } : {
      style: gridStyle, index: index, datum: tick,
      cx: 0, cy: 0, r: scale(tick), startAngle: startAngle, endAngle: endAngle
    };
  },
  getAxisLabelProps: function (props, calculatedValues) {
    var axisType = calculatedValues.axisType,
        radius = calculatedValues.radius,
        style = calculatedValues.style,
        scale = calculatedValues.scale;
    var axisLabelComponent = props.axisLabelComponent;

    if (axisType !== "radial") {
      return {};
    }
    var labelPlacement = axisLabelComponent.props && axisLabelComponent.props.labelPlacement ? axisLabelComponent.props.labelPlacement : props.labelPlacement;
    var labelStyle = style && style.axisLabel || {};
    var axisAngle = axisType === "radial" ? this.getAxisAngle(props, scale) : undefined;
    var textAngle = labelStyle.angle || LabelHelpers.getPolarAngle(_assign({}, props, { labelPlacement: labelPlacement }), axisAngle);
    var labelRadius = radius + (labelStyle.padding || 0);
    var textAnchor = labelStyle.textAnchor || LabelHelpers.getTextPolarAnchor(_assign({}, props, { labelPlacement: labelPlacement }), axisAngle);
    var verticalAnchor = labelStyle.verticalAnchor || LabelHelpers.getPolarVerticalAnchor(_assign({}, props, { labelPlacement: labelPlacement }), axisAngle);
    return {
      style: labelStyle,
      angle: textAngle,
      textAnchor: textAnchor,
      verticalAnchor: verticalAnchor,
      text: props.label,
      x: this.getPosition(labelRadius, Helpers.degreesToRadians(axisAngle), "x"),
      y: this.getPosition(labelRadius, Helpers.degreesToRadians(axisAngle), "y")
    };
  },
  getPosition: function (r, angle, axis) {
    return axis === "x" ? r * Math.cos(angle) : -r * Math.sin(angle);
  },
  getAxisProps: function (modifiedProps, calculatedValues) {
    var style = calculatedValues.style,
        axisType = calculatedValues.axisType,
        radius = calculatedValues.radius,
        scale = calculatedValues.scale;
    var startAngle = modifiedProps.startAngle,
        endAngle = modifiedProps.endAngle,
        _modifiedProps$innerR = modifiedProps.innerRadius,
        innerRadius = _modifiedProps$innerR === undefined ? 0 : _modifiedProps$innerR;

    var axisAngle = axisType === "radial" ? Helpers.degreesToRadians(this.getAxisAngle(modifiedProps, scale)) : undefined;
    return axisType === "radial" ? {
      style: style.axis,
      x1: this.getPosition(innerRadius, axisAngle, "x"),
      x2: this.getPosition(radius, axisAngle, "x"),
      y1: this.getPosition(innerRadius, axisAngle, "y"),
      y2: this.getPosition(radius, axisAngle, "y")
    } : {
      style: style.axis,
      cx: 0, cy: 0, r: radius, startAngle: startAngle, endAngle: endAngle
    };
  },
  getEvaluatedStyles: function (style, tick, index) {
    return {
      tickStyle: this.evaluateStyle(style.ticks, tick, index),
      labelStyle: this.evaluateStyle(style.tickLabels, tick, index),
      gridStyle: this.evaluateStyle(style.grid, tick, index)
    };
  },
  getRole: function (props) {
    if (props.dependentAxis) {
      return props.theme && props.theme.dependentAxis ? "dependentAxis" : "axis";
    }

    return props.theme && props.theme.independentAxis ? "independentAxis" : "axis";
  },
  getShallowMergedThemeProps: function (props, role) {
    var axisTheme = props.theme.axis || {};
    return _defaults({}, props.theme[role], axisTheme);
  },
  modifyProps: function (props, fallbackProps, role) {
    if (role !== "axis") {
      props.theme[role] = this.getShallowMergedThemeProps(props, role);
    }
    return Helpers.modifyProps(props, fallbackProps, role);
  },
  getBaseProps: function (props, fallbackProps) {
    var _this2 = this;

    var role = this.getRole(props);
    props = this.modifyProps(props, fallbackProps, role);
    var calculatedValues = this.getCalculatedValues(props);
    var style = calculatedValues.style,
        scale = calculatedValues.scale,
        ticks = calculatedValues.ticks,
        domain = calculatedValues.domain;
    var _props = props,
        width = _props.width,
        height = _props.height,
        standalone = _props.standalone,
        theme = _props.theme;

    var axisProps = this.getAxisProps(props, calculatedValues);
    var axisLabelProps = this.getAxisLabelProps(props, calculatedValues);
    var initialChildProps = { parent: { style: style.parent, ticks: ticks, scale: scale, width: width, height: height, domain: domain, standalone: standalone, theme: theme }
    };

    return ticks.reduce(function (childProps, tick, index) {
      childProps[index] = {
        axis: axisProps,
        axisLabel: axisLabelProps,
        ticks: _this2.getTickProps(props, calculatedValues, tick, index),
        tickLabels: _this2.getTickLabelProps(props, calculatedValues, tick, index),
        grid: _this2.getGridProps(props, calculatedValues, tick, index)
      };

      return childProps;
    }, initialChildProps);
  },
  getTicks: function (props, scale) {
    var tickValues = props.tickValues,
        tickCount = props.tickCount;

    if (tickValues && Array.isArray(tickValues)) {
      if (Helpers.stringTicks(props)) {
        return _range(1, props.tickValues.length + 1);
      }
      return tickValues.length ? tickValues : scale.domain();
    } else if (scale.ticks && _isFunction(scale.ticks)) {
      var scaleTicks = scale.ticks(tickCount);
      var ticks = Array.isArray(scaleTicks) && scaleTicks.length ? scaleTicks : scale.domain();
      var filteredTicks = _includes(ticks, 0) ? _without(ticks, 0) : ticks;
      return filteredTicks.length ? filteredTicks : ticks;
    }
    return scale.domain();
  },
  filterTicks: function (ticks, scale) {
    var compareTicks = function (t) {
      return scale(t) % (2 * Math.PI);
    };
    return _uniqBy(ticks, compareTicks);
  },
  getTickFormat: function (props, scale) {
    if (props.tickFormat && _isFunction(props.tickFormat)) {
      return props.tickFormat;
    } else if (props.tickFormat && Array.isArray(props.tickFormat)) {
      return function (x, index) {
        return props.tickFormat[index];
      };
    } else if (Helpers.stringTicks(props)) {
      return function (x, index) {
        return props.tickValues[index];
      };
    } else if (scale.tickFormat && _isFunction(scale.tickFormat)) {
      return scale.tickFormat();
    } else {
      return function (x) {
        return x;
      };
    }
  }
};